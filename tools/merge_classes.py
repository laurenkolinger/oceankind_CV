#!/usr/bin/env python3

"""
Author: Serena Mou, LO
Updated: March 2025
===
Merges, removes, and relabels YOLO format classes based on a mapping configuration.

Purpose:
- Combine multiple classes into a single class (e.g., merge different grouper variants into one "Grouper" class)
- Remove unwanted classes from the dataset
- Give new descriptive names to merged classes

Input Options:
1. Class Mapping Text File (Recommended):
   - Generated by class_lister.py
   - Easy to read format showing current classes and where to specify merges
   - Supports class removal and new class labels

2. Direct Dictionary (Legacy):
   - Python dictionary mapping old class IDs to new ones
   - Basic mapping without descriptive labels

3. YAML Workflow:
   - Manual creation of class_merger.yaml
   - Advanced usage for complex mappings

Output:
- Creates a new directory with:
  - Processed label files with updated class IDs
  - data.yaml and test.yaml with new class configuration
  - class_merger.yaml documenting the mapping

Example Usage:
1. Generate mapping template:
   python tools/class_lister.py --dir dataset_dir --output class_mapping.txt

2. Edit class_mapping.txt to specify:
   - Which classes to merge together
   - Which classes to remove (use 'remove')
   - Names for the new merged classes

3. Apply the mapping:
   python tools/merge_classes.py --save output_dir --labels_in labels_dir --mapping class_mapping.txt

===
"""

import os
import yaml
import glob
import sys
import argparse
import ast
from typing import Dict, Optional, Tuple, List

class mergeClasses():
    def __init__(self, labels_in: str, save: str, merge_file: Optional[str], 
                 data_file: Optional[str], new_cls: Optional[str], use_case: str, 
                 class_dict: Optional[Dict] = None, mapping_file: Optional[str] = None,
                 images_in: Optional[str] = None):
        """
        Initialize the class merger.
        
        Args:
            labels_in: Path to input labels
            save: Path to save output
            merge_file: Path to merger yaml file
            data_file: Path to data yaml file
            new_cls: Comma-separated string of new class names
            use_case: 'G' for generate or 'M' for merge
            class_dict: Optional direct class mapping dictionary
            mapping_file: Optional path to class mapping text file
            images_in: Optional path to input images directory
        """
        self.labels_in = labels_in
        self.save = save
        self.merge_file = merge_file
        self.data_file = data_file
        self.class_dict = class_dict
        self.mapping_file = mapping_file
        self.images_in = images_in
        
        # extract classes from data.yaml if provided
        if self.data_file is not None:
            with open(self.data_file,'r') as stream:
                data_loaded = yaml.safe_load(stream)
            try:
                self.old_cls_dict = data_loaded["names"]
            except:
                sys.exit("--data has no \"names\" section of original class names")
                
        if new_cls is not None:
            print(f"New classes to merge into: {new_cls}")    
            try:
                new_cls = new_cls.split(',')
                self.new_cls_dict = {k:v for k,v in enumerate(new_cls)}
            except:
                sys.exit("--newclasses argument incorrectly formatted. See README for more info")
        self.use_case = use_case

    def load_mapping_file(self) -> Tuple[Dict[str, str], Dict[str, str]]:
        """
        Load and parse the class mapping text file.
        
        Returns:
            Tuple[Dict[str, str], Dict[str, str]]: (class_mapping, class_labels)
            - class_mapping: Maps old class IDs to new class IDs
            - class_labels: Maps new class IDs to their labels
        """
        try:
            mapping = {}
            labels = {}
            
            with open(self.mapping_file, 'r') as f:
                lines = f.readlines()
            
            # Skip header until we find the divider
            start_idx = 0
            for i, line in enumerate(lines):
                if line.strip().startswith('---'):
                    start_idx = i + 1
                    break
            
            # Process each line
            for line in lines[start_idx:]:
                # Skip comments, empty lines, and dividers
                if line.strip().startswith('#') or not line.strip() or line.strip().startswith('---'):
                    continue
                    
                # Split line into columns
                parts = [p.strip() for p in line.split('|')]
                if len(parts) != 4:
                    continue
                    
                class_id, class_name, map_to, new_label = parts
                
                # Skip if no mapping specified
                if map_to.strip() in ['__________', '']:
                    continue
                    
                # Handle 'remove' keyword
                if map_to.strip().lower() == 'remove':
                    mapping[class_id.strip()] = '-1'  # Use -1 to indicate removal
                else:
                    try:
                        # Validate mapping is an integer
                        new_class = str(int(map_to.strip()))
                        mapping[class_id.strip()] = new_class
                        
                        # Store label if provided
                        if new_label.strip() and new_label.strip() != '__________':
                            labels[new_class] = new_label.strip()
                    except ValueError:
                        print(f"Warning: Invalid mapping '{map_to.strip()}' for class {class_id.strip()}, skipping")
                        continue
            
            if not mapping:
                raise ValueError("No valid mappings found in file")
                
            return mapping, labels
            
        except Exception as e:
            sys.exit(f"Error parsing mapping file: {e}")

    def load_class_dict(self, dict_path: str) -> bool:
        """
        Load class changes from a Python dictionary file.
        The file should contain a dictionary named 'class_change' mapping old class IDs to new ones.
        
        Args:
            dict_path: Path to the Python file containing class mapping dictionary
            
        Returns:
            bool: True if loading successful, False otherwise
        """
        try:
            with open(dict_path, 'r') as f:
                content = f.read()
                # Extract the dictionary part
                dict_str = content[content.find('{'):content.rfind('}')+1]
                # Safely evaluate the dictionary string
                self.class_dict = ast.literal_eval(dict_str)
                print(f"Successfully loaded class mapping dictionary from {dict_path}")
                return True
        except Exception as e:
            print(f"Error loading class dictionary: {e}")
            return False

    def validate_class_mapping(self) -> bool:
        """
        Validate that all class mappings are valid integers.
        
        Returns:
            bool: True if all mappings are valid, False otherwise
        """
        if not self.class_dict:
            return False
            
        try:
            # Verify all keys and values can be converted to integers
            for old_class, new_class in self.class_dict.items():
                int(old_class)  # Check if old_class can be converted to int
                if new_class != '-1':  # Allow -1 for removal
                    int(new_class)  # Check if new_class can be converted to int
            return True
        except ValueError as e:
            print(f"Invalid class mapping: {e}")
            print("All class IDs must be integers or string representations of integers")
            return False

    def dict_to_yaml_format(self, class_labels: Optional[Dict[str, str]] = None) -> Optional[Dict]:
        """
        Convert direct dictionary format to class_merger.yaml format.
        
        Args:
            class_labels: Optional dictionary mapping new class IDs to labels
            
        Returns:
            Dict: YAML-compatible dictionary structure or None if conversion fails
        """
        if not self.class_dict:
            return None
            
        # Get unique new class IDs from mapping
        new_class_ids = sorted(set(int(v) for v in self.class_dict.values() if v != '-1'))
        
        # Create new_classes dictionary
        new_classes = {}
        for i in new_class_ids:
            if class_labels and str(i) in class_labels:
                new_classes[i] = class_labels[str(i)]
            else:
                new_classes[i] = f"class_{i}"
        
        # Create old_classes dictionary with mapping
        old_classes = {}
        for k, v in self.class_dict.items():
            if v != '-1':  # Skip removed classes
                old_classes[int(k)] = f"class_{k},{v}"
            
        return {
            "new_classes": new_classes,
            "old_classes": old_classes
        }

    def write_class_merger(self):
        """Generate and write class_merger.yaml file"""
        print(f"Generating a class_merger.yaml file with data from {self.data_file} and the new classes")
        
        yaml_path = os.path.join(self.save, "class_merger.yaml")
        
        # Create the output directory if it doesn't exist
        os.makedirs(os.path.dirname(yaml_path), exist_ok=True)
        
        if os.path.exists(yaml_path):
            ow = input(f"File {yaml_path} already exists. Overwrite? Y/N: ")
            if ow.lower() != "y":
                sys.exit("ERROR: class_merger.yaml already exists and NOT overwriting. Select different path in --save argument.")
            print("Overwriting class_merger.yaml")

        data = {
            "new_classes": self.new_cls_dict,
            "old_classes": self.old_cls_dict
        }
        
        with open(yaml_path, 'w') as outfile:
            yaml.dump(data, outfile, sort_keys=False)
        print(f"Saved class merger configuration to {yaml_path}")

    def read_class_merger(self) -> Dict:
        """
        Read and parse the class merger yaml file.
        
        Returns:
            Dict: Mapping of new class IDs to lists of old class IDs
        """
        try:
            with open(self.merge_file, 'r') as stream:
                data_loaded = yaml.safe_load(stream)

            to_merge = data_loaded['old_classes']
            new_classes = data_loaded['new_classes']
            self.new_cls = list(new_classes.values())
            
            new_class_mapping = {}
            for cls in to_merge:
                if ',' not in str(to_merge[cls]):
                    sys.exit("class_merger.yaml not in correct format. Each old class must specify its new class ID after a comma.")
                [n, merge] = str(to_merge[cls]).split(',')
                merge = int(merge)
                if merge not in new_class_mapping:
                    new_class_mapping[merge] = [cls]
                else:
                    new_class_mapping[merge].append(cls)
            return new_class_mapping
            
        except Exception as e:
            sys.exit(f"Error reading class_merger.yaml: {e}")

    def copy_images(self):
        """Copy images to output directory maintaining YOLO structure"""
        # Use provided images directory if available, otherwise try default location
        if self.images_in:
            images_dir = self.images_in
        else:
            # Default behavior: look in parallel all_images directory
            labels_dir = os.path.dirname(self.labels_in)
            dataset_root = os.path.dirname(labels_dir)
            images_dir = os.path.join(dataset_root, "all_images")
        
        if not os.path.exists(images_dir):
            print(f"Warning: Images directory not found at {images_dir}")
            return
            
        # Create output images directory
        out_images = os.path.join(self.save, "all_images")
        os.makedirs(out_images, exist_ok=True)
        
        if os.path.exists(out_images) and os.listdir(out_images):
            ow = input(f"WARNING: {out_images} folder exists and is not empty. Overwrite contents? Y/N: ")
            if ow.lower() != "y":
                sys.exit(f"ERROR: {out_images} not empty and overwrite NOT selected. Choose different --save path.")
            print("Overwriting existing images...")
        
        # Get list of image files that have corresponding labels
        label_files = [os.path.splitext(f)[0] for f in os.listdir(self.labels_in) if f.endswith('.txt')]
        
        # Copy images
        print(f"Copying images to {out_images}...")
        copied = 0
        for label_base in label_files:
            # Check for common image extensions
            for ext in ['.jpg', '.jpeg', '.png', '.tif', '.tiff']:
                img_file = label_base + ext
                img_path = os.path.join(images_dir, img_file)
                if os.path.exists(img_path):
                    import shutil
                    shutil.copy2(img_path, os.path.join(out_images, img_file))
                    copied += 1
                    break
        print(f"Copied {copied} images")

    def change_classes(self, mapping: Dict):
        """
        Apply class changes to all label files according to mapping and copy corresponding images.
        
        Args:
            mapping: Dictionary mapping new class IDs to lists of old class IDs
        """
        # Process labels
        out_folder = os.path.join(self.save, "all_labels")
        os.makedirs(out_folder, exist_ok=True)

        if os.path.exists(out_folder) and os.listdir(out_folder):
            ow = input(f"WARNING: {out_folder} folder exists and is not empty. Overwrite contents? Y/N: ")
            if ow.lower() != "y":
                sys.exit(f"ERROR: {out_folder} not empty and overwrite NOT selected. Choose different --save path.")
            print("Overwriting existing labels...")

        labels_in = glob.glob(os.path.join(self.labels_in, "*.txt"))
        if not labels_in:
            sys.exit(f"No label files found in {self.labels_in}")

        print(f"Processing {len(labels_in)} label files...")
        
        # Create reverse mapping for faster lookup
        reverse_mapping = {}
        for new_cls, old_classes in mapping.items():
            for old_cls in old_classes:
                reverse_mapping[int(old_cls)] = new_cls

        for label in labels_in:
            save_name = os.path.basename(label)
            new_lines = []
            
            with open(label, "r") as f:
                for line in f:
                    parts = line.strip().split()
                    if not parts:
                        continue
                        
                    try:
                        old_cls = int(parts[0])
                        if old_cls not in reverse_mapping:
                            print(f"Warning: Class {old_cls} in {save_name} not found in mapping")
                            continue
                            
                        new_cls = reverse_mapping[old_cls]
                        new_lines.append(f"{new_cls} {' '.join(parts[1:])}")
                    except ValueError:
                        print(f"Warning: Invalid class ID in {save_name}: {parts[0]}")
                        continue

            save_out = os.path.join(out_folder, save_name)
            with open(save_out, "w") as f:
                f.write('\n'.join(new_lines))
                if new_lines:  # Add newline at end of file if there's content
                    f.write('\n')
                    
        print(f"Processed label files saved to {out_folder}")
        
        # Copy corresponding images
        self.copy_images()

    def write_yaml(self):
        """Generate data.yaml and test.yaml files with updated class information"""
        yaml_path = os.path.join(self.save, "data.yaml")
        test_yaml_path = os.path.join(self.save, "test.yaml")

        # Create output directory if it doesn't exist
        os.makedirs(self.save, exist_ok=True)

        for path in [yaml_path, test_yaml_path]:
            if os.path.exists(path):
                ow = input(f"{os.path.basename(path)} already exists at {path}. Overwrite? Y/N: ")
                if ow.lower() != "y":
                    sys.exit(f"ERROR: Not overwriting {path}. Please select different save path.")
                print(f"Overwriting {os.path.basename(path)}")

        # Create class enumeration
        new_cls_enum = {k:v for k,v in enumerate(self.new_cls)}
        
        # Base configuration
        base_config = {
            "path": self.save,
            "names": new_cls_enum
        }

        # Data yaml for training
        data = base_config.copy()
        data.update({
            "train": "train",
            "val": "valid"
        })

        # Test yaml for evaluation
        test = base_config.copy()
        test.update({
            "train": "train",
            "val": "test"
        })

        # Write files
        for path, config in [(yaml_path, data), (test_yaml_path, test)]:
            with open(path, 'w') as f:
                yaml.dump(config, f, sort_keys=False)
            print(f"Created {os.path.basename(path)}")

    def run(self):
        """Main execution method"""
        if self.use_case.lower() == "g":
            self.write_class_merger()
        elif self.use_case.lower() == "m":
            mapping = self.read_class_merger()
            self.change_classes(mapping)
            self.write_yaml()
        else:
            sys.exit("Invalid use case. Must be 'G' for generate or 'M' for merge.")

def arg_parse():
    parser = argparse.ArgumentParser(
        description='Generate a class_merger.yaml or merge classes with a class_merger.yaml for labels that are in YOLO format')

    parser.add_argument("--newclasses", dest = "new_cls",
            help = "The class names to be merged to, separated by commas. Ex: cls0,cls1,cls2", 
            default = None, type = str, required=False)
    
    parser.add_argument("--data", dest = "data",
            help = "Path to data.yaml containing all original classes", 
            default = None, type = str, required=False)
    
    parser.add_argument("--labels_in", dest = "labels_in",
            help = "Path to labels to be merged", 
            default = None, type = str, required=False)
    
    parser.add_argument("--save", dest = "save",
            help = "Path to save location of merged labels - can be the same as --labels_in to overwrite", 
            default = None, type = str, required=True)
    
    parser.add_argument("--merge", dest = "merge_file",
            help = "Path to merge yaml file", 
            default = None, type = str, required=False)
    
    parser.add_argument("--class_dict", dest = "class_dict",
            help = "Path to Python file containing class mapping dictionary", 
            default = None, type = str, required=False)
    
    parser.add_argument("--mapping", dest = "mapping_file",
            help = "Path to class mapping text file (generated by class_lister.py)", 
            default = None, type = str, required=False)
    
    parser.add_argument("--images_in", dest = "images_in",
            help = "Path to directory containing input images", 
            default = None, type = str, required=False)
    
    return parser.parse_args()

def main():
    args = arg_parse()
    
    # If mapping file is provided, use that workflow
    if args.mapping_file:
        if not os.path.exists(args.mapping_file):
            sys.exit(f"Class mapping file {args.mapping_file} not found")
            
        mc = mergeClasses(args.labels_in, args.save, None, None, None, 'M', 
                         mapping_file=args.mapping_file, images_in=args.images_in)
        mapping, labels = mc.load_mapping_file()
        mc.class_dict = mapping
        
        if not mc.validate_class_mapping():
            sys.exit("Invalid class mapping in mapping file")
            
        yaml_data = mc.dict_to_yaml_format(labels)
        yaml_path = os.path.join(args.save, "class_merger.yaml")
        
        # Create output directory if it doesn't exist
        os.makedirs(args.save, exist_ok=True)
        
        with open(yaml_path, 'w') as f:
            yaml.dump(yaml_data, f, sort_keys=False)
            
        print(f"Created class_merger.yaml at {yaml_path}")
        mc.merge_file = yaml_path
        mapping = mc.read_class_merger()
        mc.change_classes(mapping)
        mc.write_yaml()
        print("Class merging completed successfully")
        return
    
    # If class_dict is provided, use that workflow
    if args.class_dict:
        if not os.path.exists(args.class_dict):
            sys.exit(f"Class dictionary file {args.class_dict} not found")
        
        mc = mergeClasses(args.labels_in, args.save, None, None, None, 'M')
        if not mc.load_class_dict(args.class_dict):
            sys.exit("Failed to load class dictionary")
            
        if not mc.validate_class_mapping():
            sys.exit("Invalid class mapping in dictionary")
            
        yaml_data = mc.dict_to_yaml_format()
        yaml_path = os.path.join(args.save, "class_merger.yaml")
        
        with open(yaml_path, 'w') as f:
            yaml.dump(yaml_data, f, sort_keys=False)
            
        print(f"Created class_merger.yaml at {yaml_path}")
        mc.merge_file = yaml_path
        mapping = mc.read_class_merger()
        mc.change_classes(mapping)
        mc.write_yaml()
        print("Class merging completed successfully")
        return

    # Original workflow
    use_case = input("Do you need to generate a merger file (G) or merge classes from existing class_merger.yaml (M)? G/M? ")
    
    # generating a merger file
    if use_case.lower() == "g":
        # check for new class list and data.yaml of classes
        if args.new_cls is None or args.data is None or args.save is None:
            sys.exit("Please ensure --newclasses, --data and --save arguments are included")
        if args.labels_in is not None or args.merge_file is not None:
            print("WARNING: --labels_in and --merge are being ignored\n") 

        labels_in = None
        save = args.save
        merge_file = None
        data = args.data
        new_cls = args.new_cls
    
    # merge from exisitng class_merger.yaml
    elif use_case.lower() == "m":
        if args.labels_in is None or args.save is None or args.merge_file is None:
            sys.exit("Please ensure --labels_in, --save and --merge arguments are included")
        if args.new_cls is not None or args.data is not None:
            print("WARNING: --newclasses and --data arguments are being ignored\n") 

        labels_in = args.labels_in
        save = args.save
        merge_file = args.merge_file
        data = None
        new_cls = None
    
    else:
        sys.exit("Please type G to generate a class_merger.yaml file or M to merge labels from an existing class_merger.yaml file")
    mc = mergeClasses(labels_in, save, merge_file, data, new_cls, use_case, images_in=args.images_in)
    mc.run()
    print("\nDONE")
if __name__=='__main__':
    main()
